// 원시타입 vs 객체타입
// 원시타입 
// -> Number, String, Boolean 등..
// -> 값 자체로써 변수에 저장되고 복사 된다
// -> 불변값 (= 메모리 값 수정되지 않음)

// 객체타입
// -> Object, Array, Function 등..
// -> 참조값을 통해 변수에 저장되고 복사 된다
// -> 가변값 (= 메모리 값 수정됨)


// 1. 원시타입 = 불변값( ⭐️ 실제로 메모리에 저장된 원본 데이터의 값이 변경되지 않는다! )
let p1 = 1; // 1번째 메모리에 저장
let p2 = p1; // 2번째 메모리에 저장 ( ⭐️ 실제로 메모리의 값은 수정되지 않고 유지됨! )
p2 = 2; // 3번째 메모리에 저장하고, p2는 3메모리를 가리키게 된다



// 2. 객체타입 = 가변값 ( ⭐️ 원본데이터가 수정됨 )
let o1 = { name : '조승연' }; // 참조값(= 주소값)을 갖고, 주소에 별도의 메모리 공간에 객체( { name : '조승연' } )자체를 저장함
// 원시타입과 다르게 저장하는 이유 : 객체안의 데이터는 증가/감소 변경하기 때문에

let o2 = o1; // o1의 o2로 복사. o1과 o2를 같은 주소를 바라봄
o2.name = '홍길동'; // o1, o2의 주소값이 같아 함께 데이터가 변경됨


// 3. 객체타입 주의사항

// 1) 의도치 않게 값이 수정될 수 있다. (= 사이드 이펙트)
// 방법 : 객체 안에 spread연산자를 통해 내부 프로퍼티만 넣음 => 새로운 객체로 새로운 주소값을 사용할 수 있음
let oo1 = { name : '조승연' };
let oo2 = { ...oo1 };
// 얕은 복사 vs 깊은 복사
// 얕은 복사 : 객체의 참조값을 복사 ( 원본 객체가 수정될 수 있어 위험 ) ( 2. 객체타입 예시와 동일 )
// 깊은 복사 : 새로운 객체를 생성하면서 프로퍼티만 따로 복사 ( 원복 객체가 수정될 일이 없어 안전 ) ( 빙법 예시 동일 )

// 2) 객체간의 비교는 기본적으로 참조값을 기준으로 이루어진다.
let a1 = { name : '조승연' };
let a2 = a1;
let a3 = { ...a1 };
console.log(a1 === a2); // true
console.log(a1 === a3); // false (참조값(=주소값)이 다르므로 완전 다른 객체임)
// JSON.stringify() 자바스크립트 내장 함수를 활용해, 객체를 문자열로 변환하는 기능
console.log(
  JSON.stringify(a1) === JSON.stringify(a3)
); // true
// 얕은 비교 vs 깊은 비교
// 얕은 비교 : 참조값을 기준으로 비교 (42, 43라인)
// 깊은 비교 : 객체를 문자열로 변환하여 비교, JSON.stringify() 등의 내장 함수를 이용해야 함 (46라인)

// 3) 배열과 함수도 사실 객체이다
// 배열 : 순차 저장, 순회, .. 등등
// 함수 : 호출, 선언, .. 등등